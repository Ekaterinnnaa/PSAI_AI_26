import numpy as np
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt

X = np.array([
    [6., 4.],
    [-6., 4.],
    [6., -4.],
    [-6., -4.]
])

e = np.array([1., 1., 0., 1.]).reshape(-1, 1)

def predict(w, x, T):
    return x @ w - T

def train_online(X, e, alpha=0.002, epochs=2000, shuffle=True, tol=1e-7):
    N = X.shape[0]
    w = np.zeros((X.shape[1], 1))
    T = 0.0
    errors = []
    prev_mse = float('inf')

    print(f"Обучение с α = {alpha:.6f} начато...")

    for epoch in range(epochs):
        if shuffle:
            idx = np.random.permutation(N)
            X_shuf, e_shuf = X[idx], e[idx]
        else:
            X_shuf, e_shuf = X, e

        for i in range(N):
            xi = X_shuf[i:i+1]
            ti = e_shuf[i]
            y = predict(w, xi, T)
            err = y - ti
            grad_w = xi.T @ err
            grad_T = -err[0,0]
            w -= alpha * grad_w
            T -= alpha * grad_T

        y_all = predict(w, X, T)
        mse = np.mean((y_all - e) ** 2)
        errors.append(mse)

        if epoch % 100 == 0 and epoch > 0:
            print(f"Эпоха {epoch:4d}   MSE = {mse:.8f}")

        if epoch > 30 and abs(mse - prev_mse) < tol:
            print(f"Ранняя остановка на эпохе {epoch}")
            break
        prev_mse = mse

    print(f"Обучение завершено. Финальная MSE = {mse:.8f}\n")
    return w, T, errors

alphas = [0.0003, 0.0006, 0.001, 0.002]
results = {}

for alpha in alphas:
    w, T, errs = train_online(X, e, alpha=alpha)
    results[alpha] = (w, T, errs)

plt.figure(figsize=(10, 5.5))
for alpha, (_, _, errs) in results.items():
    plt.plot(errs, label=f'α = {alpha}', linewidth=1.6)
plt.yscale('log')
plt.xlabel('Эпоха')
plt.ylabel('MSE (лог. шкала)')
plt.grid(True, alpha=0.3)
plt.legend()
plt.tight_layout()
plt.show()

best_alpha = min(results, key=lambda a: results[a][2][-1])
w, T = results[best_alpha][0], results[best_alpha][1]
print(f"Выбрана модель с α = {best_alpha:.6f} (лучшая MSE)\n")

new_points = []
new_classes = []

print("Введите точки (x1 x2) или exit для завершения\n")

while True:
    s = input("x1 x2 → ").strip()
    if not s or s.lower() in ['exit']:
        break

    try:
        x1, x2 = map(float, s.split())
        pt = np.array([[x1, x2]])

        S = predict(w, pt, T)[0, 0]
        cls = 1 if S >= 0.5 else 0
        color_name = "красный" if cls == 1 else "синий"

        print(f"  S      = {S:>9.6f}")
        print(f"  Класс  = {cls} ({color_name})")

        new_points.append([x1, x2])
        new_classes.append(cls)

        fig, ax = plt.subplots(figsize=(9, 8))

        c0 = X[e.flatten() == 0]
        c1 = X[e.flatten() == 1]
        ax.scatter(c0[:,0], c0[:,1], color='blue', s=150, label='класс 0', edgecolors='black')
        ax.scatter(c1[:,0], c1[:,1], color='red', s=150, label='класс 1', edgecolors='black')

        w1, w2 = w.flatten()
        x1_vals = np.linspace(-9, 9, 500)
        if abs(w2) > 1e-6:
            x2_vals = (T + 0.5 - w1 * x1_vals) / w2
            ax.plot(x1_vals, x2_vals, 'g-', lw=2.4, label='линия (порог 0.5)')

        for pt_xy, cl in zip(new_points, new_classes):
            col = 'red' if cl == 1 else 'blue'
            ax.scatter(pt_xy[0], pt_xy[1], color=col, marker='X', s=220,
                       edgecolors='black', linewidth=1.6, alpha=0.95)

        ax.set_xlim(-9, 9)
        ax.set_ylim(-9, 9)
        ax.set_xlabel('x1')
        ax.set_ylabel('x2')
        ax.grid(True, alpha=0.25)
        ax.legend()
        plt.tight_layout()
        plt.show()

    except ValueError:
        print("Ошибка: введите два числа через пробел\n")
    except Exception as ex:
        print(f"Ошибка: {ex}\n")

print("Программа завершена")
